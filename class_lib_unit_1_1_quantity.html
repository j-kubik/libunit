<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9"/>
<title>LibUnit: LibUnit::Quantity&lt; Unit, T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">LibUnit
   </div>
   <div id="projectbrief">Library for compile time unit checking and converting</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>LibUnit</b></li><li class="navelem"><a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_lib_unit_1_1_quantity-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">LibUnit::Quantity&lt; Unit, T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="class_lib_unit_1_1_quantity.html" title="Quantity class represents a variable of type T coupled with a unit. ">Quantity</a> class represents a variable of type T coupled with a unit.  
 <a href="class_lib_unit_1_1_quantity.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="quantity_8h_source.html">quantity.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2df55c8b95478fd9c73d07c5e6493626"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2df55c8b95478fd9c73d07c5e6493626"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_unit_1_1_quantity.html#a2df55c8b95478fd9c73d07c5e6493626">Quantity</a> ()</td></tr>
<tr class="memdesc:a2df55c8b95478fd9c73d07c5e6493626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contructs <a class="el" href="class_lib_unit_1_1_quantity.html" title="Quantity class represents a variable of type T coupled with a unit. ">Quantity</a> with non-initialized value. <br /></td></tr>
<tr class="separator:a2df55c8b95478fd9c73d07c5e6493626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2cdd4bc6913e1d72c37d7e904db1baf"><td class="memTemplParams" colspan="2">template&lt;typename T2 &gt; </td></tr>
<tr class="memitem:ab2cdd4bc6913e1d72c37d7e904db1baf"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_lib_unit_1_1_quantity.html#ab2cdd4bc6913e1d72c37d7e904db1baf">Quantity</a> (const <a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a>&lt; Unit, T2 &gt; &amp;q)</td></tr>
<tr class="memdesc:ab2cdd4bc6913e1d72c37d7e904db1baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contructs a <a class="el" href="class_lib_unit_1_1_quantity.html" title="Quantity class represents a variable of type T coupled with a unit. ">Quantity</a> from quantity of the same unit but different underlying type.  <a href="#ab2cdd4bc6913e1d72c37d7e904db1baf">More...</a><br /></td></tr>
<tr class="separator:ab2cdd4bc6913e1d72c37d7e904db1baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49645384466d1f8e798c5bcbd2a7daa8"><td class="memTemplParams" colspan="2">template&lt;typename U , typename T2 &gt; </td></tr>
<tr class="memitem:a49645384466d1f8e798c5bcbd2a7daa8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_lib_unit_1_1_quantity.html#a49645384466d1f8e798c5bcbd2a7daa8">Quantity</a> (const <a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a>&lt; U, T2 &gt; &amp;q)</td></tr>
<tr class="memdesc:a49645384466d1f8e798c5bcbd2a7daa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contructs a quantity from quantity of the same dimension but different underlying type.  <a href="#a49645384466d1f8e798c5bcbd2a7daa8">More...</a><br /></td></tr>
<tr class="separator:a49645384466d1f8e798c5bcbd2a7daa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74399e4a7b0b20f100140705eab856d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_unit_1_1_quantity.html#ab74399e4a7b0b20f100140705eab856d">Quantity</a> (T value)</td></tr>
<tr class="memdesc:ab74399e4a7b0b20f100140705eab856d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a quantity with a given value.  <a href="#ab74399e4a7b0b20f100140705eab856d">More...</a><br /></td></tr>
<tr class="separator:ab74399e4a7b0b20f100140705eab856d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5030bdb335fd37d9b314b6a0a02557"><td class="memTemplParams" colspan="2">template&lt;typename U , typename T2 &gt; </td></tr>
<tr class="memitem:a8a5030bdb335fd37d9b314b6a0a02557"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_lib_unit_1_1_quantity.html#a8a5030bdb335fd37d9b314b6a0a02557">operator=</a> (const <a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a>&lt; U, T2 &gt; &amp;q)</td></tr>
<tr class="memdesc:a8a5030bdb335fd37d9b314b6a0a02557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a quantity from quantity of the same dimension but different underlying type.  <a href="#a8a5030bdb335fd37d9b314b6a0a02557">More...</a><br /></td></tr>
<tr class="separator:a8a5030bdb335fd37d9b314b6a0a02557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4efbf2b67bf45470218af95c08639f12"><td class="memTemplParams" colspan="2">template&lt;typename U , typename T2 &gt; </td></tr>
<tr class="memitem:a4efbf2b67bf45470218af95c08639f12"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_lib_unit_1_1_quantity.html#a4efbf2b67bf45470218af95c08639f12">operator+</a> (const <a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a>&lt; U, T2 &gt; &amp;q) const </td></tr>
<tr class="memdesc:a4efbf2b67bf45470218af95c08639f12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a quantity of the same dimension but different underlying type.  <a href="#a4efbf2b67bf45470218af95c08639f12">More...</a><br /></td></tr>
<tr class="separator:a4efbf2b67bf45470218af95c08639f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843fca090b8c1c81ef6d597486ab5d34"><td class="memTemplParams" colspan="2">template&lt;typename U , typename T2 &gt; </td></tr>
<tr class="memitem:a843fca090b8c1c81ef6d597486ab5d34"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_lib_unit_1_1_quantity.html#a843fca090b8c1c81ef6d597486ab5d34">operator-</a> (const <a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a>&lt; U, T2 &gt; &amp;q) const </td></tr>
<tr class="memdesc:a843fca090b8c1c81ef6d597486ab5d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts a quantity of the same dimension but different underlying type.  <a href="#a843fca090b8c1c81ef6d597486ab5d34">More...</a><br /></td></tr>
<tr class="separator:a843fca090b8c1c81ef6d597486ab5d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d69e914fefad225224d68bf94ba651e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_unit_1_1_quantity.html#a5d69e914fefad225224d68bf94ba651e">operator+</a> () const </td></tr>
<tr class="memdesc:a5d69e914fefad225224d68bf94ba651e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer promotion operator.  <a href="#a5d69e914fefad225224d68bf94ba651e">More...</a><br /></td></tr>
<tr class="separator:a5d69e914fefad225224d68bf94ba651e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf44283e5bc4f7d6713f02910d88ccfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_unit_1_1_quantity.html#acf44283e5bc4f7d6713f02910d88ccfc">operator-</a> () const </td></tr>
<tr class="memdesc:acf44283e5bc4f7d6713f02910d88ccfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additive inverse operator.  <a href="#acf44283e5bc4f7d6713f02910d88ccfc">More...</a><br /></td></tr>
<tr class="separator:acf44283e5bc4f7d6713f02910d88ccfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bccdb6e715d0940b7e7c8a22a5bc946"><td class="memTemplParams" colspan="2">template&lt;typename U , typename T2 &gt; </td></tr>
<tr class="memitem:a0bccdb6e715d0940b7e7c8a22a5bc946"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_lib_unit_1_1_quantity.html#a0bccdb6e715d0940b7e7c8a22a5bc946">operator%</a> (const <a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a>&lt; U, T2 &gt; &amp;q) const </td></tr>
<tr class="memdesc:a0bccdb6e715d0940b7e7c8a22a5bc946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division rest operator.  <a href="#a0bccdb6e715d0940b7e7c8a22a5bc946">More...</a><br /></td></tr>
<tr class="separator:a0bccdb6e715d0940b7e7c8a22a5bc946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594fd9ef4751bb3b9ff8a44ae2905127"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a594fd9ef4751bb3b9ff8a44ae2905127"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_lib_unit_1_1_quantity.html#a594fd9ef4751bb3b9ff8a44ae2905127">operator%</a> (const U &amp;u) const </td></tr>
<tr class="memdesc:a594fd9ef4751bb3b9ff8a44ae2905127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division rest operator.  <a href="#a594fd9ef4751bb3b9ff8a44ae2905127">More...</a><br /></td></tr>
<tr class="separator:a594fd9ef4751bb3b9ff8a44ae2905127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9b3ce0d0d643582f5ecf0770bbe794"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_unit_1_1_quantity.html#aec9b3ce0d0d643582f5ecf0770bbe794">operator++</a> ()</td></tr>
<tr class="memdesc:aec9b3ce0d0d643582f5ecf0770bbe794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment operator.  <a href="#aec9b3ce0d0d643582f5ecf0770bbe794">More...</a><br /></td></tr>
<tr class="separator:aec9b3ce0d0d643582f5ecf0770bbe794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfee8b882e9908a42916f1fcc961d4e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_unit_1_1_quantity.html#adfee8b882e9908a42916f1fcc961d4e8">operator++</a> (int)</td></tr>
<tr class="memdesc:adfee8b882e9908a42916f1fcc961d4e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment operator.  <a href="#adfee8b882e9908a42916f1fcc961d4e8">More...</a><br /></td></tr>
<tr class="separator:adfee8b882e9908a42916f1fcc961d4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744fbc718606f3b1917abe690998cada"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_unit_1_1_quantity.html#a744fbc718606f3b1917abe690998cada">operator--</a> ()</td></tr>
<tr class="memdesc:a744fbc718606f3b1917abe690998cada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement operator.  <a href="#a744fbc718606f3b1917abe690998cada">More...</a><br /></td></tr>
<tr class="separator:a744fbc718606f3b1917abe690998cada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1969143afd8c8ae83dd9de68f56d3f02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_unit_1_1_quantity.html#a1969143afd8c8ae83dd9de68f56d3f02">operator--</a> (int)</td></tr>
<tr class="memdesc:a1969143afd8c8ae83dd9de68f56d3f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement operator.  <a href="#a1969143afd8c8ae83dd9de68f56d3f02">More...</a><br /></td></tr>
<tr class="separator:a1969143afd8c8ae83dd9de68f56d3f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad383ed6703341aebbaff56cba5c196b1"><td class="memTemplParams" colspan="2">template&lt;typename U , typename T2 &gt; </td></tr>
<tr class="memitem:ad383ed6703341aebbaff56cba5c196b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_lib_unit_1_1_quantity.html#ad383ed6703341aebbaff56cba5c196b1">operator+=</a> (const <a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a>&lt; U, T2 &gt; &amp;q)</td></tr>
<tr class="memdesc:ad383ed6703341aebbaff56cba5c196b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator.  <a href="#ad383ed6703341aebbaff56cba5c196b1">More...</a><br /></td></tr>
<tr class="separator:ad383ed6703341aebbaff56cba5c196b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae928b06ba771fc9710e5a346f71937c1"><td class="memTemplParams" colspan="2">template&lt;typename U , typename T2 &gt; </td></tr>
<tr class="memitem:ae928b06ba771fc9710e5a346f71937c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_lib_unit_1_1_quantity.html#ae928b06ba771fc9710e5a346f71937c1">operator-=</a> (const <a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a>&lt; U, T2 &gt; &amp;q)</td></tr>
<tr class="memdesc:ae928b06ba771fc9710e5a346f71937c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction assignment operator.  <a href="#ae928b06ba771fc9710e5a346f71937c1">More...</a><br /></td></tr>
<tr class="separator:ae928b06ba771fc9710e5a346f71937c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7532b2475943d715bc363571a2f557bf"><td class="memTemplParams" colspan="2">template&lt;typename T2 &gt; </td></tr>
<tr class="memitem:a7532b2475943d715bc363571a2f557bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_lib_unit_1_1_quantity.html#a7532b2475943d715bc363571a2f557bf">operator*=</a> (const T2 &amp;q)</td></tr>
<tr class="memdesc:a7532b2475943d715bc363571a2f557bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment operator.  <a href="#a7532b2475943d715bc363571a2f557bf">More...</a><br /></td></tr>
<tr class="separator:a7532b2475943d715bc363571a2f557bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09da2b0bdd5de6ccdb50ab7499bcc409"><td class="memTemplParams" colspan="2">template&lt;typename T2 &gt; </td></tr>
<tr class="memitem:a09da2b0bdd5de6ccdb50ab7499bcc409"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_lib_unit_1_1_quantity.html#a09da2b0bdd5de6ccdb50ab7499bcc409">operator/=</a> (const T2 &amp;q)</td></tr>
<tr class="memdesc:a09da2b0bdd5de6ccdb50ab7499bcc409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division assignment operator.  <a href="#a09da2b0bdd5de6ccdb50ab7499bcc409">More...</a><br /></td></tr>
<tr class="separator:a09da2b0bdd5de6ccdb50ab7499bcc409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06175caa5c03f35f7d92e9a733c4ff3e"><td class="memTemplParams" colspan="2">template&lt;typename T2 &gt; </td></tr>
<tr class="memitem:a06175caa5c03f35f7d92e9a733c4ff3e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_lib_unit_1_1_quantity.html#a06175caa5c03f35f7d92e9a733c4ff3e">operator%=</a> (const T2 &amp;q)</td></tr>
<tr class="memdesc:a06175caa5c03f35f7d92e9a733c4ff3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division rest assignment operator.  <a href="#a06175caa5c03f35f7d92e9a733c4ff3e">More...</a><br /></td></tr>
<tr class="separator:a06175caa5c03f35f7d92e9a733c4ff3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5bcba4a0efb5b40bffde6aee78a7b19"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_unit_1_1_quantity.html#ad5bcba4a0efb5b40bffde6aee78a7b19">operator T</a> () const </td></tr>
<tr class="memdesc:ad5bcba4a0efb5b40bffde6aee78a7b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion to underlying type operator.  <a href="#ad5bcba4a0efb5b40bffde6aee78a7b19">More...</a><br /></td></tr>
<tr class="separator:ad5bcba4a0efb5b40bffde6aee78a7b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd20244210370878eee6d8ebeafba55e"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_unit_1_1_quantity.html#acd20244210370878eee6d8ebeafba55e">value</a> () const </td></tr>
<tr class="memdesc:acd20244210370878eee6d8ebeafba55e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal value of quantity.  <a href="#acd20244210370878eee6d8ebeafba55e">More...</a><br /></td></tr>
<tr class="separator:acd20244210370878eee6d8ebeafba55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac86b03d3093f2e6e3e978856bf4859"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_unit_1_1_quantity.html#afac86b03d3093f2e6e3e978856bf4859">ref</a> ()</td></tr>
<tr class="memdesc:afac86b03d3093f2e6e3e978856bf4859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to internal value of quantity.  <a href="#afac86b03d3093f2e6e3e978856bf4859">More...</a><br /></td></tr>
<tr class="separator:afac86b03d3093f2e6e3e978856bf4859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Comparison operators.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Perform comparison between quantities of the same dimension and possibly different underlying types.</p>
<p>Standard (implicit) conversion between underlying types and scaling between different units of the same dimension is performed before comparisons.</p>
<p>If dimensions of compared quantities are different, compilation error is generated. </p>
</div></td></tr>
<tr class="memitem:afdb2a2a8bfce9be8734a42b18feb0a42"><td class="memTemplParams" colspan="2"><a class="anchor" id="afdb2a2a8bfce9be8734a42b18feb0a42"></a>
template&lt;typename U , typename T2 &gt; </td></tr>
<tr class="memitem:afdb2a2a8bfce9be8734a42b18feb0a42"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a>&lt; U, T2 &gt; &amp;q) const </td></tr>
<tr class="separator:afdb2a2a8bfce9be8734a42b18feb0a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab194676e2d2f0a6d18e55eaf954a5011"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab194676e2d2f0a6d18e55eaf954a5011"></a>
template&lt;typename U , typename T2 &gt; </td></tr>
<tr class="memitem:ab194676e2d2f0a6d18e55eaf954a5011"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a>&lt; U, T2 &gt; &amp;q) const </td></tr>
<tr class="separator:ab194676e2d2f0a6d18e55eaf954a5011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4674b51a5e6f37e9100ece88a3e4b66f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4674b51a5e6f37e9100ece88a3e4b66f"></a>
template&lt;typename U , typename T2 &gt; </td></tr>
<tr class="memitem:a4674b51a5e6f37e9100ece88a3e4b66f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a>&lt; U, T2 &gt; &amp;q) const </td></tr>
<tr class="separator:a4674b51a5e6f37e9100ece88a3e4b66f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40036135dafac6ab55ac8acd2684db7"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae40036135dafac6ab55ac8acd2684db7"></a>
template&lt;typename U , typename T2 &gt; </td></tr>
<tr class="memitem:ae40036135dafac6ab55ac8acd2684db7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a>&lt; U, T2 &gt; &amp;q) const </td></tr>
<tr class="separator:ae40036135dafac6ab55ac8acd2684db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2866b56831238e8063c71eec43232b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9e2866b56831238e8063c71eec43232b"></a>
template&lt;typename U , typename T2 &gt; </td></tr>
<tr class="memitem:a9e2866b56831238e8063c71eec43232b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a>&lt; U, T2 &gt; &amp;q) const </td></tr>
<tr class="separator:a9e2866b56831238e8063c71eec43232b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8377f9c0b36e2f39b7cfb324887c0702"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8377f9c0b36e2f39b7cfb324887c0702"></a>
template&lt;typename U , typename T2 &gt; </td></tr>
<tr class="memitem:a8377f9c0b36e2f39b7cfb324887c0702"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a>&lt; U, T2 &gt; &amp;q) const </td></tr>
<tr class="separator:a8377f9c0b36e2f39b7cfb324887c0702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Additional operators.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Provided for ease of use for different underlying types. These operators perform same operations as used on underlying types of operands. No conversions or compiler errors are genereated by LibUnit. </p>
</div></td></tr>
<tr class="memitem:a16541d93d1018df6bbcd0ce1eaefa9be"><td class="memTemplParams" colspan="2"><a class="anchor" id="a16541d93d1018df6bbcd0ce1eaefa9be"></a>
template&lt;typename U &gt; </td></tr>
<tr class="memitem:a16541d93d1018df6bbcd0ce1eaefa9be"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator[]</b> (const U &amp;u)</td></tr>
<tr class="separator:a16541d93d1018df6bbcd0ce1eaefa9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6853984e36176bccb6e57c64269e692"><td class="memTemplParams" colspan="2"><a class="anchor" id="af6853984e36176bccb6e57c64269e692"></a>
template&lt;typename U &gt; </td></tr>
<tr class="memitem:af6853984e36176bccb6e57c64269e692"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator[]</b> (const U &amp;u) const </td></tr>
<tr class="separator:af6853984e36176bccb6e57c64269e692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade8c394d07865e177c73c10ecfab582b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade8c394d07865e177c73c10ecfab582b"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> ()</td></tr>
<tr class="separator:ade8c394d07865e177c73c10ecfab582b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1257b76fbdfacfdc9bfdbee5d7b1e9a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1257b76fbdfacfdc9bfdbee5d7b1e9a9"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> () const </td></tr>
<tr class="separator:a1257b76fbdfacfdc9bfdbee5d7b1e9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52aca16bb01624ffcffe9c8c2738852a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52aca16bb01624ffcffe9c8c2738852a"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>operator-&gt;</b> ()</td></tr>
<tr class="separator:a52aca16bb01624ffcffe9c8c2738852a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a3249555103cedd12ddefb206f4a0f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a3249555103cedd12ddefb206f4a0f3"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>operator-&gt;</b> () const </td></tr>
<tr class="separator:a0a3249555103cedd12ddefb206f4a0f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27938a8ba8f19b1c837fc017c7e24802"><td class="memTemplParams" colspan="2"><a class="anchor" id="a27938a8ba8f19b1c837fc017c7e24802"></a>
template&lt;typename U &gt; </td></tr>
<tr class="memitem:a27938a8ba8f19b1c837fc017c7e24802"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-&gt;*</b> (const U &amp;u)</td></tr>
<tr class="separator:a27938a8ba8f19b1c837fc017c7e24802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40bc5385626b9601f3abeb6aefd081d4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a40bc5385626b9601f3abeb6aefd081d4"></a>
template&lt;typename U &gt; </td></tr>
<tr class="memitem:a40bc5385626b9601f3abeb6aefd081d4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-&gt;*</b> (const U &amp;u) const </td></tr>
<tr class="separator:a40bc5385626b9601f3abeb6aefd081d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c052ec8a4137ad79f7c56915f95d40"><td class="memTemplParams" colspan="2"><a class="anchor" id="a49c052ec8a4137ad79f7c56915f95d40"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a49c052ec8a4137ad79f7c56915f95d40"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator()</b> (Args &amp;&amp;...args)</td></tr>
<tr class="separator:a49c052ec8a4137ad79f7c56915f95d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aac7842167cc796eb1f8709e925480f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0aac7842167cc796eb1f8709e925480f"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a0aac7842167cc796eb1f8709e925480f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator()</b> (Args &amp;&amp;...args) const </td></tr>
<tr class="separator:a0aac7842167cc796eb1f8709e925480f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd4715df2baf1bde9734ea37a5bd820d"><td class="memTemplParams" colspan="2"><a class="anchor" id="acd4715df2baf1bde9734ea37a5bd820d"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:acd4715df2baf1bde9734ea37a5bd820d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator()</b> (const Args &amp;...args)</td></tr>
<tr class="separator:acd4715df2baf1bde9734ea37a5bd820d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2145fc4bdc5a227fe5b2a55de7b1472"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac2145fc4bdc5a227fe5b2a55de7b1472"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ac2145fc4bdc5a227fe5b2a55de7b1472"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator()</b> (const Args &amp;...args) const </td></tr>
<tr class="separator:ac2145fc4bdc5a227fe5b2a55de7b1472"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a8a228d6ebd8b2881b41cae0fb5a0ea35"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a228d6ebd8b2881b41cae0fb5a0ea35"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator</b> (std::ostream &amp;, const <a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a>&lt; Unit, T &gt; &amp;)</td></tr>
<tr class="separator:a8a228d6ebd8b2881b41cae0fb5a0ea35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd67cc1ae23585d4764d0ae1adecdb6"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lib_unit_1_1_quantity.html#a0cd67cc1ae23585d4764d0ae1adecdb6">operator&gt;&gt;</a> (std::istream &amp;, const <a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a>&lt; Unit, T &gt; &amp;)</td></tr>
<tr class="memdesc:a0cd67cc1ae23585d4764d0ae1adecdb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Istream input operator overload.  <a href="#a0cd67cc1ae23585d4764d0ae1adecdb6">More...</a><br /></td></tr>
<tr class="separator:a0cd67cc1ae23585d4764d0ae1adecdb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Unit, typename T&gt;<br />
class LibUnit::Quantity&lt; Unit, T &gt;</h3>

<p><a class="el" href="class_lib_unit_1_1_quantity.html" title="Quantity class represents a variable of type T coupled with a unit. ">Quantity</a> class represents a variable of type T coupled with a unit. </p>
<p>Template parameters:</p><ul>
<li>Unit: type describing unit in which quantity is expressed.</li>
<li>T: Underlying type that is used to store the value.</li>
</ul>
<p><a class="el" href="class_lib_unit_1_1_quantity.html" title="Quantity class represents a variable of type T coupled with a unit. ">Quantity</a> is one of core classes of LibUnit. It contains a value of underlying type. It's template parameter describes unit in which stored value is expressed.</p>
<p>All mathematical operator avialable in C/C++ are overloaded in such a way that the results obey regular unit arithmetics. If requested operation cannot be performed, compilation error is generated.</p>
<p>All methods of this class are declared inline and (hopefully) a good compiler should be able to generate identical code as when working directly on a variable of nderlying type.</p>
<h3>Standard conversions</h3>
<p>Whenever required, while performig arythmetics on quantities of different unit in LibUnit, one of the quantities must be converted to the same unit as the other. Unit conversion is only possible if dimensions of both units are the same.</p>
<p>In order to compute value of quantity in unit <code>V</code>, representing the quantity in unit <code>U</code>, the ratio of factor of unit <code>U</code> to the factor of unit <code>V</code> is computed. Then value of quantity in unit <code>U</code> is then multiplied by this ratio, yieldig value of quantity in unit <code>V</code>.</p>
<p>If underlying type of assigned quantities are different, standard type coercion is performed. If a result of a computation is a quantity computed from a set of quantities, then underlying type of such quantity is the same as a type of a result of equivalent computation performed directly upon variables of underlying types <em>including unit conversion</em>.</p>
<p>Attempting to use units with different dimensions in above circumstances will cause compilation error. This allows for compile-time unit checking, and is one of the main motivation for LibUnit. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ab2cdd4bc6913e1d72c37d7e904db1baf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Unit, typename T&gt; </div>
<div class="memtemplate">
template&lt;typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_lib_unit_1_1_quantity.html">LibUnit::Quantity</a>&lt; Unit, T &gt;::<a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a>&lt; Unit, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contructs a <a class="el" href="class_lib_unit_1_1_quantity.html" title="Quantity class represents a variable of type T coupled with a unit. ">Quantity</a> from quantity of the same unit but different underlying type. </p>
<p>Standard (implicit) conversion between underlying types is performed. </p>

</div>
</div>
<a class="anchor" id="a49645384466d1f8e798c5bcbd2a7daa8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Unit, typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_lib_unit_1_1_quantity.html">LibUnit::Quantity</a>&lt; Unit, T &gt;::<a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a>&lt; U, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contructs a quantity from quantity of the same dimension but different underlying type. </p>
<p>Standard (implicit) conversion between underlying types is performed. Scaling between different units of the same dimension is performed.</p>
<p>If dimension of quantity q is different than dimension of constructed quantity, compilation error is generated. </p>

</div>
</div>
<a class="anchor" id="ab74399e4a7b0b20f100140705eab856d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Unit, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_lib_unit_1_1_quantity.html">LibUnit::Quantity</a>&lt; Unit, T &gt;::<a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a quantity with a given value. </p>
<p>No conversions are performed on the value. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad5bcba4a0efb5b40bffde6aee78a7b19"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Unit, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_lib_unit_1_1_quantity.html">LibUnit::Quantity</a>&lt; Unit, T &gt;::operator T </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion to underlying type operator. </p>
<dl class="section return"><dt>Returns</dt><dd>internal value of quantity.</dd></dl>
<p>No conversions or compiler errors are genereated by LibUnit. </p>

</div>
</div>
<a class="anchor" id="a0bccdb6e715d0940b7e7c8a22a5bc946"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Unit, typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="class_lib_unit_1_1_quantity.html">LibUnit::Quantity</a>&lt; Unit, T &gt;::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a>&lt; U, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division rest operator. </p>
<dl class="section return"><dt>Returns</dt><dd>quantity instance of the same unit as leftside quantity.</dd></dl>
<p>Standard (implicit) conversion between underlying types and scaling between different units of the same dimension is performed before division.</p>
<p>If dimensions of divided quantities are different, compilation error is generated. </p>

</div>
</div>
<a class="anchor" id="a594fd9ef4751bb3b9ff8a44ae2905127"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Unit, typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="class_lib_unit_1_1_quantity.html">LibUnit::Quantity</a>&lt; Unit, T &gt;::operator% </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division rest operator. </p>
<dl class="section return"><dt>Returns</dt><dd>quantity instance of the same unit as leftside quantity.</dd></dl>
<p>Overload for non-quantity values. Since non-quantity values have no unit attached, no conversions is being performed. </p>

</div>
</div>
<a class="anchor" id="a06175caa5c03f35f7d92e9a733c4ff3e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Unit, typename T&gt; </div>
<div class="memtemplate">
template&lt;typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a>&amp; <a class="el" href="class_lib_unit_1_1_quantity.html">LibUnit::Quantity</a>&lt; Unit, T &gt;::operator%= </td>
          <td>(</td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division rest assignment operator. </p>
<p>Performs division rest assignment between quantity and non-quantity or dimensionless quantity.</p>
<p>Non-quantity operand has no unit, so no scaling is performed.</p>
<p>If second operand is not dimensionless, compilation error is generated. </p>

</div>
</div>
<a class="anchor" id="a7532b2475943d715bc363571a2f557bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Unit, typename T&gt; </div>
<div class="memtemplate">
template&lt;typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a>&amp; <a class="el" href="class_lib_unit_1_1_quantity.html">LibUnit::Quantity</a>&lt; Unit, T &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication assignment operator. </p>
<p>Performs multiplication assignment between quantity and non-quantity or dimensionless quantity.</p>
<p>Non-quantity operand has no unit, so no scaling is performed.</p>
<p>If second operand is not dimensionless, compilation error is generated. </p>

</div>
</div>
<a class="anchor" id="a4efbf2b67bf45470218af95c08639f12"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Unit, typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="class_lib_unit_1_1_quantity.html">LibUnit::Quantity</a>&lt; Unit, T &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a>&lt; U, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a quantity of the same dimension but different underlying type. </p>
<dl class="section return"><dt>Returns</dt><dd>quantity instance of the same unit as leftside quantity.</dd></dl>
<p>Standard (implicit) conversion between underlying types and scaling between different units of the same dimension is performed before addition.</p>
<p>If dimensions of added quantities are different, compilation error is generated. </p>

</div>
</div>
<a class="anchor" id="a5d69e914fefad225224d68bf94ba651e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Unit, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="class_lib_unit_1_1_quantity.html">LibUnit::Quantity</a>&lt; Unit, T &gt;::operator+ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integer promotion operator. </p>
<dl class="section return"><dt>Returns</dt><dd>quantity of the same unit and underlying type same as integer promotion of underlying type of promoted quantity.</dd></dl>
<p>Performs integer promotion on held value and returns qunatity of the same unit and apropriate underlying type. </p>

</div>
</div>
<a class="anchor" id="aec9b3ce0d0d643582f5ecf0770bbe794"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Unit, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a>&amp; <a class="el" href="class_lib_unit_1_1_quantity.html">LibUnit::Quantity</a>&lt; Unit, T &gt;::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment operator. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to this quantity.</dd></dl>
<p>Increments stored value. </p>

</div>
</div>
<a class="anchor" id="adfee8b882e9908a42916f1fcc961d4e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Unit, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a> <a class="el" href="class_lib_unit_1_1_quantity.html">LibUnit::Quantity</a>&lt; Unit, T &gt;::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment operator. </p>
<dl class="section return"><dt>Returns</dt><dd>copy of the quantity before incremntation.</dd></dl>
<p>Increments stored value. </p>

</div>
</div>
<a class="anchor" id="ad383ed6703341aebbaff56cba5c196b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Unit, typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a>&amp; <a class="el" href="class_lib_unit_1_1_quantity.html">LibUnit::Quantity</a>&lt; Unit, T &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a>&lt; U, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. </p>
<p>Performs addition assignment between quantities of the same dimension and different underlying type.</p>
<p>Standard (implicit) conversion of underlying type and scaling is performed before addition if second opearand has different unit.</p>
<p>If dimensions of operands are different, compilation error is generated. </p>

</div>
</div>
<a class="anchor" id="a843fca090b8c1c81ef6d597486ab5d34"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Unit, typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="class_lib_unit_1_1_quantity.html">LibUnit::Quantity</a>&lt; Unit, T &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a>&lt; U, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts a quantity of the same dimension but different underlying type. </p>
<dl class="section return"><dt>Returns</dt><dd>quantity instance of the same unit as leftside quantity.</dd></dl>
<p>Standard (implicit) conversion between underlying types and scaling between different units of the same dimension is performed before addition.</p>
<p>If dimensions of subtracted quantities are different, compilation error is generated. </p>

</div>
</div>
<a class="anchor" id="acf44283e5bc4f7d6713f02910d88ccfc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Unit, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a> <a class="el" href="class_lib_unit_1_1_quantity.html">LibUnit::Quantity</a>&lt; Unit, T &gt;::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Additive inverse operator. </p>
<dl class="section return"><dt>Returns</dt><dd>quantity of the same unit and underlying type same as additive inverse of underlying type of inversed quantity.</dd></dl>
<p>Performs additive inversion on held value and returns qunatity of the same unit and apropriate underlying type. </p>

</div>
</div>
<a class="anchor" id="a744fbc718606f3b1917abe690998cada"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Unit, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a>&amp; <a class="el" href="class_lib_unit_1_1_quantity.html">LibUnit::Quantity</a>&lt; Unit, T &gt;::operator-- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrement operator. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to this quantity.</dd></dl>
<p>Decrements stored value. </p>

</div>
</div>
<a class="anchor" id="a1969143afd8c8ae83dd9de68f56d3f02"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Unit, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a> <a class="el" href="class_lib_unit_1_1_quantity.html">LibUnit::Quantity</a>&lt; Unit, T &gt;::operator-- </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrement operator. </p>
<dl class="section return"><dt>Returns</dt><dd>copy of the quantity before decremntation.</dd></dl>
<p>Decrements stored value. </p>

</div>
</div>
<a class="anchor" id="ae928b06ba771fc9710e5a346f71937c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Unit, typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a>&amp; <a class="el" href="class_lib_unit_1_1_quantity.html">LibUnit::Quantity</a>&lt; Unit, T &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a>&lt; U, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction assignment operator. </p>
<p>Performs subtraction assignment between quantities of the same dimension and different underlying type.</p>
<p>Standard (implicit) conversion of underlying type and scaling is performed before subtraction if second opearand has different unit.</p>
<p>If second operand is not dimensionless, compilation error is generated. </p>

</div>
</div>
<a class="anchor" id="a09da2b0bdd5de6ccdb50ab7499bcc409"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Unit, typename T&gt; </div>
<div class="memtemplate">
template&lt;typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a>&amp; <a class="el" href="class_lib_unit_1_1_quantity.html">LibUnit::Quantity</a>&lt; Unit, T &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division assignment operator. </p>
<p>Performs division assignment between quantity and non-quantity or dimensionless quantity.</p>
<p>Non-quantity operand has no unit, so no scaling is performed.</p>
<p>If second operand is not dimensionless, compilation error is generated. </p>

</div>
</div>
<a class="anchor" id="a8a5030bdb335fd37d9b314b6a0a02557"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Unit, typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a>&amp; <a class="el" href="class_lib_unit_1_1_quantity.html">LibUnit::Quantity</a>&lt; Unit, T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a>&lt; U, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a quantity from quantity of the same dimension but different underlying type. </p>
<p>Standard (implicit) conversion between underlying types is performed. Scaling between different units of the same dimension is performed.</p>
<p>If dimension of quantity q is different than dimension of assigned quantity, compilation error is generated. </p>

</div>
</div>
<a class="anchor" id="afac86b03d3093f2e6e3e978856bf4859"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Unit, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="class_lib_unit_1_1_quantity.html">LibUnit::Quantity</a>&lt; Unit, T &gt;::ref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reference to internal value of quantity. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to internal value of quantity.</dd></dl>
<p>Can be used to change value of quantity without dimension checking. Use with caution. </p>

</div>
</div>
<a class="anchor" id="acd20244210370878eee6d8ebeafba55e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Unit, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="class_lib_unit_1_1_quantity.html">LibUnit::Quantity</a>&lt; Unit, T &gt;::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal value of quantity. </p>
<dl class="section return"><dt>Returns</dt><dd>internal value of quantity.</dd></dl>
<p>No conversions or compiler errors are genereated by LibUnit. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a0cd67cc1ae23585d4764d0ae1adecdb6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Unit, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lib_unit_1_1_quantity.html">Quantity</a>&lt; Unit, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Istream input operator overload. </p>
<p>Reads internal value of quantity from istream. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/root/projects/units/libunit/include/<a class="el" href="quantity_8h_source.html">quantity.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 31 2015 09:43:45 for LibUnit by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9
</small></address>
</body>
</html>
